{
  "hash": "db2850d337b17e6aff1a818be3ad8354",
  "result": {
    "markdown": "---\ntoc: true\ndescription: Advent of Code 2023 Solutions in Python\ncategories:\n  - python\ntitle: \"\\U0001F384\"\ndate: '2023-12-01'\ncode-line-numbers: true\nhighlight-style: github\n---\n\n## 1\n[https://adventofcode.com/2023/day/1](https://adventofcode.com/2023/day/1)\n\nQuite challenging for a day 1! Learned some new regex for part 2 which was fun - positive lookahead `?=...` essentially means you can extract overlapping matches\n\n::: {.column-page}\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nwith open(\"aoc/1/input.txt\", \"r\") as f:\n    inp = f.readlines()\n\nONE_TO_NINE = list(map(str, list(range(1, 10))))\n\n\ndef extract_first_num(a):\n    for char in a:\n        if char in ONE_TO_NINE:\n            return char\n\n\ntotal = 0\nfor row in inp:\n    total += int(extract_first_num(row) + extract_first_num(row[::-1]))\n\nprint(\"Part 1 answer:\")\nprint(total)\n\nimport re\n\n\ndef convert_num(x):\n    num_map = dict(\n        zip(\n            [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"],\n            ONE_TO_NINE,\n        )\n    )\n\n    if x.isnumeric():\n        return x\n    else:\n        return num_map[x]\n\n\ntotal = 0\nfor row in inp:\n    cap = re.findall(r\"(?=(\\d|one|two|three|four|five|six|seven|eight|nine))\", row)\n    total += int(convert_num(cap[0]) + convert_num(cap[-1]))\n\n\nprint(\"Part 2 answer:\")\nprint(total)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPart 1 answer:\n54951\nPart 2 answer:\n55218\n```\n:::\n:::\n\n\n:::\n## 2\n[https://adventofcode.com/2023/day/2](https://adventofcode.com/2023/day/2)\n\nFeel like this should have been day one ðŸ˜„\n\n::: {.column-page}\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nwith open(\"aoc/2/input.txt\", \"r\") as f:\n    inp = f.readlines()\n    \ntotal = 0\n    \nfor row in inp:\n    index, game = row.split(\":\")\n    index = int(index.replace(\"Game \", \"\"))\n    possible = True\n    \n    for game in game.split(\";\"):\n        bag_one = dict(\n            red=12,\n            green=13,\n            blue=14,\n        )\n        \n        for colours in game.split(\",\"):\n            num, color = colours.strip().split(\" \")\n            if int(num) > bag_one[color]:\n                possible = False\n                \n    if possible:\n        total += index\n                \nprint(\"Part 1 answer:\")\nprint(total)\n\nimport math\n\ntotal = 0\n\nfor row in inp:\n    index, game = row.split(\":\")\n    index = int(index.replace(\"Game \", \"\"))\n    bag_max = dict(\n            red=0,\n            green=0,\n            blue=0,\n        )\n    for game in game.split(\";\"):   \n        for colours in game.split(\",\"):\n            num, color = colours.strip().split(\" \")\n            if int(num) > bag_max[color]:\n                bag_max[color] = int(num)\n                \n    total += math.prod(bag_max.values())\n    \nprint(\"Part 2 answer:\")\nprint(total)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPart 1 answer:\n2563\nPart 2 answer:\n70768\n```\n:::\n:::\n\n\n:::\n## 3\n[https://adventofcode.com/2023/day/3](https://adventofcode.com/2023/day/3)\n\nI don't like grids ðŸ«  I probably made this harder than it needed to be. If I were to do this again I probably would have just used euclidian distance comparisons\n\n::: {.column-page}\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport re\nfrom collections import defaultdict\nfrom itertools import product\n\nwith open(\"aoc/3/input.txt\", \"r\") as f:\n    inp = f.readlines()\n    \n# examine all unique chars to populate regex pattern and SYMBOLS set\n# print(set(y for x in inp for y in x))\n    \ntotal = 0\nSYMBOLS = {\"*\", \"#\", \"$\", \"+\", \"-\", \"%\", \"=\", \"/\", \"&\", \"@\"}\np = re.compile(\"\\d+|\\*|#|\\$|\\+|-|%|=|\\/|&|@\")\n\ngrid = []\nsyms = []\n\ndef poss_neighbours(i: int, j: tuple):\n    i_s = list(filter(lambda x: x >= 0, [i, i-1, i+1]))\n    j_s = list(filter(lambda x: x >=0 and x < len(inp[0]), [*j, j[0]-1, j[-1]+1]))\n    \n    for out_i in i_s:\n        for out_j in j_s:\n            if out_i == i and out_j in j:\n                continue\n            \n            yield out_i, out_j\n\nassert set(poss_neighbours(0, (0,))) == {(1,0), (1,1), (0,1)}\n    \n# construct the data structures for iterating over numbers and symbols\nfor i, row in enumerate(inp):\n    for m in p.finditer(row):\n        group = m.group()\n        js = tuple(range(*m.span()))\n        out = (group, i, js)\n        \n        if m.group() in SYMBOLS:\n            syms.append(\n                (group, i, js[0])\n            )\n        else:\n            grid.append(\n                (int(group), i, js)\n            )        \n            \n# part 1 logic\nfor num, i, js in grid:\n    poss = list(poss_neighbours(i, js))\n    \n    for _, sym_i, sym_j in syms:\n        if (sym_i, sym_j) in poss:\n            total += num\n\nprint(\"Part 1 answer:\")\nprint(total)\n\nimport math\ntotal = 0\n\n# part 2 logic\nfor sym, i, j in syms:\n    if sym == \"*\":\n        poss = list(poss_neighbours(i, (j, )))\n        \n        adj = set()\n        for num, num_i, num_js in grid:\n            for num_j in num_js:\n                if (num_i, num_j) in poss:\n                    adj.add(num)\n                \n        if len(adj) == 2:\n            total += math.prod(adj)\n\nprint(\"Part 2 answer:\")\nprint(total)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPart 1 answer:\n551094\nPart 2 answer:\n80179647\n```\n:::\n:::\n\n\n:::\n## 4\n[https://adventofcode.com/2023/day/4](https://adventofcode.com/2023/day/4)\n\nEnjoyed the logic for the second part with the copies. I'm sure there was potential to go on a wild goose chase with recursion here, so I'm happy to have avoided the temptation ðŸ¤£\n\n::: {.column-page}\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nwith open(\"aoc/4/input.txt\", \"r\") as f:\n    inp = f.readlines()\n    \ntotal = 0\n\n# part 1 logic\nfor row in inp:\n    index, rest = row.split(\":\")\n    \n    win, play = rest.split(\"|\")\n    win = list(filter(lambda x: x.isnumeric(), win.strip().split(\" \")))\n    play = list(filter(lambda x: x.isnumeric(), play.strip().split(\" \")))\n    score = 0\n    \n    \n    for num in win:\n        if num in play:\n            score += 1\n            \n    if score > 0:\n        total += 2 ** (score - 1)\n        \n\nprint(\"Part 1 answer:\")\nprint(total)\n\ntotal = 0\ncopies = {}\n\n# part 2 logic\nfor row in inp:\n    index, rest = row.split(\":\")\n    index = int(index.split(\"d\")[1].strip())\n    \n    win, play = rest.split(\"|\")\n    win = list(filter(lambda x: x.isnumeric(), win.strip().split(\" \")))\n    play = list(filter(lambda x: x.isnumeric(), play.strip().split(\" \")))\n    score = 0\n        \n    for num in win:\n        if num in play:\n            score += 1\n            \n    for x in range(index+1, index+score+1):\n        copies[x] = copies.get(x, 0) + copies.get(index, 0) + 1\n        \n    total += copies.get(index, 0) + 1\n    \n\nprint(\"Part 2 answer:\")\nprint(total)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPart 1 answer:\n23678\nPart 2 answer:\n15455663\n```\n:::\n:::\n\n\n:::\n## 5\n[https://adventofcode.com/2023/day/5](https://adventofcode.com/2023/day/5)\n\nStuck on part 2 for now...\n\n::: {.column-page}\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nfrom collections import OrderedDict\nfrom typing import Any\n\nwith open(\"aoc/5/input.txt\", \"r\") as f:\n    inp = f.readlines()\n    \n\n# create maps\nseeds = list(map(int, inp.pop(0).replace(\"seeds: \", \"\").strip().split(\" \")))\nmaps = OrderedDict()\n\nclass Mapper:\n    def __init__(self, dest, source, rng):\n        self.dest = dest\n        self.source = source\n        self.rng = rng\n        \n    def check(self, x):\n        return self.source <= x < (self.source + self.rng)\n    \n    def __call__(self, x) -> Any:\n        return x + (self.dest - self.source)\n    \n    def __repr__(self):\n        return f\"{self.dest=}|{self.source=}|{self.rng=}\"\n\n\nfor line in inp:\n    if line == \"\\n\":\n        continue\n    \n    if \"map\" in line:\n        map_name = line.replace(\"\\n\", \"\").replace(\" map:\", \"\")\n    \n    else:\n        dest, source, rng = map(int, line.replace(\"\\n\", \"\").split(\" \"))\n         \n        maps.setdefault(map_name, []).append(\n            Mapper(dest, source, rng)\n        )\n        \nlocations = []\n    \nfor x in seeds:\n    print(\"seed:\", x)\n    for k in maps.keys():\n        current_map = maps[k]\n        \n        for f in current_map:\n            if f.check(x):\n                x = f(x)\n                break\n                    \n    locations.append(x)\n    \nprint(\"Part 1 answer:\")\nprint(min(locations))\n\n\n# This is incredibly slow as too many ints to check!\n# Need to try another approach using ranges!\n# locations = []\n    \n# for z, y in zip(seeds[::2], seeds[1::2]):\n#     for x in range(z, z+y):\n#         # print(\"seed:\", x)\n#         for k in maps.keys():\n#             current_map = maps[k]\n            \n#             for f in current_map:\n#                 if f.check(x):\n#                     x = f(x)\n#                     break\n                        \n#         locations.append(x)\n\n# print(\"Part 2 answer:\")\n# print(min(locations))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nseed: 1310704671\nseed: 312415190\nseed: 1034820096\nseed: 106131293\nseed: 682397438\nseed: 30365957\nseed: 2858337556\nseed: 1183890307\nseed: 665754577\nseed: 13162298\nseed: 2687187253\nseed: 74991378\nseed: 1782124901\nseed: 3190497\nseed: 208902075\nseed: 226221606\nseed: 4116455504\nseed: 87808390\nseed: 2403629707\nseed: 66592398\nPart 1 answer:\n51752125\n```\n:::\n:::\n\n\n:::\n## 6\n[https://adventofcode.com/2023/day/6](https://adventofcode.com/2023/day/6)\n\nThere's definitely a more efficient way of doing part 2, but good enough :)\n\n::: {.column-page}\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nimport math\n\nwith open(\"aoc/6/input.txt\", \"r\") as f:\n    inp = f.readlines()\n    \ntime = map(int, filter(lambda x: x.isnumeric(), inp[0].replace(\"Time:\", \"\").strip().split(\" \")))\ndist = map(int, filter(lambda x: x.isnumeric(), inp[1].replace(\"Distance:\", \"\").strip().split(\" \")))\ntotals = []\n\nfor t, d_record in zip(time, dist):\n    total = 0\n    for i in range(t):\n        v = i\n        d = v * (t - i)\n        \n        if d > d_record:\n            total += 1\n        \n    totals.append(total)\n    \nprint(\"Part 1 answer:\")\nprint(math.prod(totals))\n\n\ntime = int(inp[0].replace(\"Time:\", \"\").replace(\" \", \"\"))\ndist = int(inp[1].replace(\"Distance:\", \"\").replace(\" \", \"\"))\ntotals = []\n\nt = time\nd_record = dist\n\ntotal = 0\nfor i in range(t):\n    v = i\n    d = v * (t - i)\n    \n    if d > d_record:\n        total += 1\n    \ntotals.append(total)\n\nprint(\"Part 2 answer:\")\nprint(math.prod(totals))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPart 1 answer:\n625968\nPart 2 answer:\n43663323\n```\n:::\n:::\n\n\n:::\n## 7\n[https://adventofcode.com/2023/day/7](https://adventofcode.com/2023/day/7)\n\nHad a solution that I thought made sense but didn't give the right answer. Went to reddit for inspiration!\n\n::: {.column-page}\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# credit to https://www.reddit.com/r/adventofcode/comments/18cnzbm/comment/kcc4azi/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button\n\nfrom collections import Counter\n\nwith open(\"aoc/7/input.txt\", \"r\") as f:\n    inp = f.readlines()\n\ndef classify_hand_type(hand: list[int]):\n    counts = Counter(hand)\n    count_of_counts = Counter(counts.values())\n    \n    if count_of_counts.get(5):\n        return 6\n    \n    elif count_of_counts.get(4):\n        return 5\n    \n    elif count_of_counts.get(3) and count_of_counts.get(2):\n        return 4\n    \n    elif count_of_counts.get(3):\n        return 3\n    \n    elif count_of_counts.get(2) == 2:\n        return 2\n    \n    elif count_of_counts.get(2):\n        return 1\n\n    else:\n        return 0\n\ndef eval_hand(line, trans):\n    hand, bid = line.split(\" \")\n    hand = hand.translate(str.maketrans('TJQKA', trans))\n    top = max(classify_hand_type(hand.replace(\"1\", x)) for x in set(hand))\n    \n    return top, hand, int(bid)\n\nprint(\"Part 1 answer:\")\nprint(\n    sum(rank * bid for rank, (*_, bid) in enumerate(sorted(map(lambda x: eval_hand(x,'ABCDE'), inp)), start=1))\n)\n\nprint(\"Part 2 answer:\")\nprint(\n    sum(rank * bid for rank, (*_, bid) in enumerate(sorted(map(lambda x: eval_hand(x,'A1CDE'), inp)), start=1))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPart 1 answer:\n254024898\nPart 2 answer:\n254115617\n```\n:::\n:::\n\n\n:::\n## 8\n[https://adventofcode.com/2023/day/8](https://adventofcode.com/2023/day/8)\n\nTried to do part 2 a silly way at first - I didn't realise that all z visits happen on the same cycle for a given starting point!\n\n::: {.column-page}\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nwith open(\"aoc/8/input.txt\", \"r\") as f:\n    inp = f.readlines()\n    \n\nclass Node:\n    def __init__(self, name, left, right):\n        self.name = name\n        self.L = left\n        self.R = right \n    \n    def transition(self, direction):\n        return getattr(self, direction)   \n\ntotal = 0\n\nins = inp[0].replace(\"\\n\", \"\")\nall_nodes = []\n\nfor row in inp[2:]:\n    start, rest = row.split(\"=\")\n    start = start.strip()\n    \n    left, right = rest.split(\",\")\n    left = left.replace(\"(\",\"\").strip()\n    right = right.replace(\")\", \"\").strip()\n    \n    all_nodes.append(\n        Node(start, left, right)\n    )\n    \ncurrent_node = [x for x in all_nodes if x.name == \"AAA\"][0]\ni = 0\n\nwhile True:\n    direction = ins[i % len(ins)]\n    \n    current_node = [\n        x for x in all_nodes if x.name == current_node.transition(direction)\n    ][0]\n    \n    i += 1\n    \n    if current_node.name == \"ZZZ\":\n        break\n    \ntotal = i\n\nprint(\"Part 1 answer:\")\nprint(total)\n \ncurrent_nodes = [x for x in all_nodes if x.name[-1] == \"A\"]\ntotals = []\n\nfor current_node in current_nodes:\n    i = 0\n    while True:\n        direction = ins[i % len(ins)]\n\n        current_node = [\n            x for x in all_nodes if x.name == current_node.transition(direction)\n        ][0]\n        \n        i += 1\n        \n        if current_node.name[-1] == \"Z\":\n            totals.append(i)\n            break\n    \nimport math\n\nprint(\"Part 2 answer:\")\nprint(math.lcm(*totals))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPart 1 answer:\n18023\nPart 2 answer:\n14449445933179\n```\n:::\n:::\n\n\n:::\n## 9\n[https://adventofcode.com/2023/day/9](https://adventofcode.com/2023/day/9)\n\n\nLearned about Lagrangian Interpolation which was ...fun? In a slightly-too-small-nutshell, we\ncan construct a summation of polynomials, where each term goes to zero when\nits corresponding x value is inputted to the function. Each term will be in\nthe form:\n\n$$\n\\frac{\\text{diff}_n}{n!}\\prod_{i=1}^{n}(x - i)\n$$\n\nWhere $n$ is the order of the term (constant, x, x^2 etc.) and $\\text{diff}_n$ is the\ndifference at the correct level in the sequence of inputs. The differencing\ntable \n    \n\n::: {.column-page}\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nimport math\n\nwith open(\"aoc/9/input.txt\", \"r\") as f:\n    inp = f.readlines()\n    \ntotal = 0\n\ndef calculate_next(diff_col, x):\n    n = len(diff_col)\n    total = 0\n    for i, diff in zip(range(n), diff_col):\n        total += diff / math.factorial(i) * math.prod(x - ns for ns in range(1,i+1))\n        \n    return total\n    \noutputs = []\nfor row in inp:\n    seq = list(map(int, row.split(\" \")))\n    diffs = [seq]\n    \n    while True:\n        diffs.append([y - x for x,y in zip(diffs[-1], diffs[-1][1:])])\n        \n        if len(set(diffs[-1])) <= 1:\n            break\n                \n    outputs.append(calculate_next([x[0] for x in diffs], len(seq) + 1))\n    \n    \nprint(\"Part 1 answer:\")\nprint(int(sum(outputs)))\n\noutputs = []\nfor row in inp:\n    seq = list(map(int, row.split(\" \")))\n    diffs = [seq]\n    \n    while True:\n        diffs.append([y - x for x,y in zip(diffs[-1], diffs[-1][1:])])\n        \n        if len(set(diffs[-1])) <= 1:\n            break\n                \n    outputs.append(calculate_next([x[0] for x in diffs], 0))\n\nprint(\"Part 2 answer:\")\nprint(int(sum(outputs)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPart 1 answer:\n1861775706\nPart 2 answer:\n1082\n```\n:::\n:::\n\n\n:::\n\n",
    "supporting": [
      "aoc_files"
    ],
    "filters": [],
    "includes": {}
  }
}